<!-- Autogenerated Documentation, do not edit manually: Sat Oct 25 17:47:39 UTC 2025 -->

# The Apik Way

---

<p align="center">
  <img src="_media/compass.png" alt="Apik Logo" width="500">
</p>

## Purpose

This document sets the principles that shape our engineering culture.  
It translates our collective values into practical expectations for developers, Technical Referents, and the Quality team.

It is not a manifesto.  
It is a framework — a set of commitments that help us deliver stable, transparent, and ethical systems.


## Our Commitments

Each developer commits to:

- producing code that is reliable, readable, and maintainable;
- adhering to shared rules and established best practices;
- clearly documenting any complex portion of code;
- making their work easy to review and understand;
- considering and applying feedback received, especially during code reviews, with a mindset of continuous improvement;
- helping teammates whenever possible, fostering a culture of support and knowledge sharing;
- resisting shortcuts and challenging outdated habits;
- anticipating potential performance and stability impacts;
- evolving their practices in line with Python recommendations and Odoo ecosystem developments;
- reporting identified risks or uncertainties;
- contributing to the improvement and ongoing update of this manifesto;
- sharing discoveries, ideas, and insights in a spirit of collective growth;
- using all available tools — including AI-based ones — responsibly and thoughtfully;
- maintaining full control over any automatically generated code.


## Document Organization

> **Working language:** All code, comments, commit messages, and documentation are written in **English**.
 
<mark>Some parts are stabilized, others are still drafted.</mark>

Each section is divided into:
- **Strict rules** — mandatory principles to be followed in all circumstances,  
- **Implementation recommendations** — expected best practices, which can only be bypassed in exceptional and documented cases.

Examples, diagrams, and code snippets are included where relevant to illustrate common patterns or expected structures.


## Partners

All developers — internal or external — are expected to follow Apik’s development charter and coding standards.

External partners operate under the same rules and undergo the same validation process by the Technical Referent and the Quality team.

---


---

# Engineering Philosophy

<mark> Status: Draft — Pending Review and Approval </mark>

Apik’s philosophy is rooted in the idea that software engineering is not an act of production — it is an act of responsibility.  
Our role is to build systems that remain understandable, maintainable, and trustworthy over time.

This philosophy guides every project, every review, and every release.  
It defines how we design, collaborate, and improve as a team of engineers.

## Our Engineering Ethic

We believe that:
- **Code is communication before computation.** It must express intent, not ego.
- **Testing is part of thinking.** It is how we prove that what we wrote is what we meant.
- **Technical debt is a shared choice.** When we take shortcuts, we document and own them.
- **Review is collaboration, not judgment.** It is how we learn, align, and grow.

We value precision over perfection.  
Perfection is rare; clarity is repeatable.

## Collaborative Spirit

At Apik, collaboration is structured and deliberate.  
The **Quality team** ensures consistency across projects.  
The **Technical Referent** guarantees technical coherence and validates releases.  
**Project Managers** coordinate delivery and client communication.  

Every participant — internal or external — shares the same expectations and responsibilities.  
Transparency and traceability are not optional; they are the foundation of trust.

We debate, we document, and we deliver together.

## Long-Term Commitment

This philosophy is meant to last.  
It evolves as tools and practices evolve, but its foundation remains:  
clarity, predictability, and shared accountability.  

Our ambition is not to build quickly — it is to build **systems that endure**.  
Every technical choice we make should still make sense a year, or five years, later.


---

# Methodology Overview

<mark> Status: Draft — Pending Review and Approval </mark>

> Apik’s engineering methodology is built on clarity, consistency, and shared responsibility.  
> Each line of code reflects a collective standard, not an individual preference.
> 
> Our goal is to maintain a development environment where every contribution — internal or external — remains **predictable, verifiable, and maintainable**.  
>
> To achieve this, all projects follow the same principles of organization, validation, and delivery.


## Common Engineering Foundation

All developments are versioned in a dedicated Git repository per client project.  
We follow a **trunk-based workflow**, meaning every validated contribution is merged directly into the `main` branch.  
This model enforces short-lived feature branches, continuous integration, and strict control over what reaches production.

Each contribution is:
- **reviewed** by the Quality team before merge,  
- **validated** by the **Technical Referent** for technical coherence,  
- and **released** under explicit approval from the **Project Manager**.

This layered responsibility ensures that no single actor controls the full delivery chain — quality and accountability are distributed.


## Guarantee of Quality and Consistency

Each project must maintain:
- a **README.md** for listing addons and project documentation,
- a **CHANGELOG.md** for release documentation,  
- a **MIGRATIONS.md** for upgrade procedures,  
- and compliance with Apik’s review and release policies.

Together, these ensure that:
- any version can be deployed or rolled back safely,  
- every feature is traceable to its origin,  
- and the integrity of the client’s environment is never compromised.



## Long-Term Vision

Apik’s engineering approach is designed for **sustainability**.  
Quality is not measured by speed of delivery, but by how long the result remains stable, understandable, and evolvable.  
Documentation, automation, and disciplined review processes are not optional — they are how we keep technical debt under control and protect our clients’ systems over time.


---

# Platforms Overview

<mark> Status: Draft — Pending Review and Approval </mark>

> This page introduces the **execution platforms** supported at Apik and how our methodology adapts to each.
> It is an entry point only — detailed procedures live in dedicated pages (CI/CD, releases, workflow, odoo.sh specifics).

---

## Supported Platforms (at a glance)

| Platform | Who operates | How we ship | Where code runs | Image build | Trunk-based notes |
|---------|---------------|-------------|-----------------|-------------|-------------------|
| **Apik Cloud (managed)** | Apik | Docker image per project | Kubernetes/containers | **Yes** (CI builds client image) | Standard trunk-based |
| **On‑premise (customer)** | Customer (with Apik support) | Docker image per project, delivered as artifact | Customer’s infra (VM, Docker host, k8s) | **Yes** (same as Cloud) | Standard trunk-based |
| **Odoo.sh** | Odoo | Git repository only | Odoo.sh platform | **No** (platform builds & runs) | Slight adaptation (detailed elsewhere) |

---

## Image Strategy (Cloud & On‑Premise)

For **Apik Cloud** and **on‑premise** deployments, we ship a **self‑contained Docker image** per project:

- The **base Odoo image** is selected by `odoo_version.txt` (major version, e.g. `18.0`).
- CI builds the **client image** by layering project code and third‑party modules on top of the selected base.
- The resulting image is **tagged by version** (e.g. `registry.example/apik/{client}-{project}:v1.5.0`) and promoted from staging → preproduction → production.
- We keep build logs and image digests for **traceability and rollback**.

**Key benefits**
- Identical artifact for staging and production (**reproducibility**).
- Zero dependency on external networks at deploy time (**reliability**).
- Controlled upgrade path (Python, Node, wkhtmltopdf, etc.) tied to the base image.

> The same image build process is used for **on‑premise**. We provide the Docker image (and compose/k8s manifests if needed), the customer deploys it in their environment.

---

## Base Image Selection

`odoo_version.txt` drives the **base Odoo version** used by CI:

```
apik/odoo:18.0-<release-date>-<enterprise>
```

- This value pins the **base image line** (e.g., `apik/odoo:18.0-20251015-enterprise`).
- Major upgrades are handled like migrations: update `odoo_version.txt`, run validations, and follow `MIGRATIONS.md`.
- Security updates to the base image are published regularly; projects **inherit** them on rebuild.



## CI/CD Overview (Cloud & On‑Premise)

1. **Build**: assemble the client image (install Python requirements, vendor third‑party code via submodules/symlinks).
2. **Test**: run lint, unit/integration tests, basic Odoo startup with `--stop-after-init`.
3. **Tag & Push**: tag image with `vX.Y.Z` and Git SHA; push to registry.
4. **Deploy**: staging auto‑deploy from `main`; preprod/prod deploys from **tags** (see `RELEASES.md`).
5. **Promote**: same image digest flows across environments.

**Image naming (example)**
```
registry.apik.cloud/{client}/{project}:v1.5.0
registry.apik.cloud/{client}/{project}:sha-{shortsha}
```



## Odoo.sh Specifics (high‑level)

On **Odoo.sh**, we do **not build Docker images**. The platform pulls the repository and builds/runs the code internally.

Methodology adjustments (details in the dedicated Odoo.sh page):
- **No image artifact**: validation relies on Odoo.sh pipelines and environments.
- **Submodules & symlinks**: supported, but must be resolvable at build time; keep the `/.third-party` + symlink pattern.
- **Trunk‑based adaptation**: shorter‑lived branches, explicit promotion (dev → staging → production) using the platform’s tools.
- **Release notes & migrations**: still mandatory (`CHANGELOG.md`, `MIGRATIONS.md`), but deployment is triggered on the platform.

> The engineering principles remain the same (review, changelog, migrations). Only the **delivery mechanism** differs.



## Responsibilities

| Role | Cloud / On‑Prem | Odoo.sh |
|------|------------------|---------|
| **Developer** | Builds run locally, fixes CI, maintains submodules/symlinks | Same; ensure Odoo.sh build passes |
| **Technical Referent** | Validates image readiness; approves release promotion | Validates branch readiness; approves platform promotion |
| **Quality Team** | Ensures template compliance, tests, and standards | Same |
| **DevOps / Hosting** | Operates registry, deploys/stabilizes environments | N/A (platform operated by Odoo) |
| **Project Manager** | Requests release, defines scope, coordinates delivery | Same |



## Policy Summary

- **One artifact per release** (Cloud/On‑Premise): the Docker image is the unit of delivery.
- **`odoo_version.txt` is the source of truth** for the base image line.
- **Trunk‑based workflow applies everywhere**; on Odoo.sh it is **lightly adapted** but still requires review, changelog, and release discipline.
- **Documentation is mandatory**: `CHANGELOG.md`, `MIGRATIONS.md`, and release approval by the **Technical Referent**.


---

# Project Organization

<mark> Status: Draft — Pending Review and Approval </mark>

> This document defines how every Odoo project is organized at Apik —
> from repository structure and module layout to **submodules**, **symlinks**, permissions, and update management.
> Its purpose is to ensure **consistency, maintainability, and reproducibility** across all environments.

---

## General Principles

Each client project lives in a **dedicated Git repository** on GitHub.
The repository contains the project's custom code and a **catalog of third‑party modules as Git submodules**
(OCA, vendors, and **Apik’s generic modules** via the `apikcloud/apik-addons` repository).

We keep a strict separation between:
- **Custom code** — project‑specific addons kept at repository root,
- **Third‑party code** — OCA, vendors, and **`apik-addons`** tracked as **submodules** under `/.third-party`.

No code duplication. No vendor code copied into the repo.

All new projects **must** use the template **[`odoo-repository-template`](https://github.com/apikcloud/odoo-repository-template)**.  
For existing projects, conformance is enforced by the [Update repository](https://github.com/apikcloud/workflows/actions/workflows/update.yml) workflow
([`.github/workflows/update.yml`](https://github.com/apikcloud/workflows)).

**Template usage policy**
- **Create new**: use GitHub **Use this template**; do **not** fork.
- **Adopt template**: open a PR titled `chore(repo): adopt odoo-repository-template` and run the Update job.
- Any drift (missing files, wrong paths, CI gaps) must be fixed **via PR** before the next release.

---

## Structure Overview

### Main Folders

| Path | Purpose |
|------|--------|
| `/` | Root directory; contains **custom modules**, symlinks, and configuration. |
| `/.third-party` | **Git submodules only** (OCA, vendors, **apikcloud/apik-addons**). |
| `/.github/workflows` | CI/CD pipelines for build, deployment, tests, and maintenance. |
| `/.devcontainer` | Development container configuration. |
| `/scripts` | Utility scripts for CI/CD, deployment, and maintenance. |
| `/apikcloud` | Deployment configuration and Kubernetes manifests when applicable. |

**Note on `apik-addons`**  
Apik’s generic modules live in a **separate repository** and are included **as a submodule**
under `/.third-party/apikcloud/apik-addons` (same rule as other third‑party sources).

### Required Files (Template Compliance)

The following files are **mandatory** in every project. They come from the
[`odoo-repository-template`](https://github.com/apikcloud/odoo-repository-template) and must not be removed.

| File | Purpose | Owner | Update rule |
|------|--------|-------|-------------|
| `requirements.txt` | Python pip dependencies | Developer | Keep minimal; pin via constraints when needed |
| `packages.txt` | System packages (APT) required at build/runtime | DevOps/Developer | Add only when strictly necessary |
| `odoo_version.txt` | Odoo **major** version (`16.0`, `17.0`, `18.0`, …) used by tooling/CI | Technical Referent | Update only when planning a major upgrade |
| `README.md` | Project purpose, environments, quickstart, links to docs | Developer | Keep concise and current |
| `CHANGELOG.md` | Human‑written release notes (Keep a Changelog) | Developer / Technical Referent | Update on every release |
| `MIGRATIONS.md` | Documented migration steps per release (if any) | Developer / Technical Referent | Update when migrations exist |
| `.pre-commit-config.yaml` | Pre‑commit hooks (lint/format/security) | Quality Team | Inherit from template; extend per project if needed |
| `.ruff.toml` / `.flake8` / `.pylintrc` | Static analysis configuration | Quality Team | Don’t relax rules without approval |
| `.gitmodules` | Catalog of third‑party submodules | Developer | Keep aligned with `/.third-party` |
| `.gitignore` / `.dockerignore` | Ignore rules for Git/Docker builds | Developer | Keep noise and secrets out of images |

**Examples**

`odoo_version.txt` (single line):
```
18.0
```

`packages.txt` (one package per line, minimal set):
```
postgresql-client
wkhtmltopdf
fonts-dejavu
```

---

## Submodule Management

All external code (OCA, vendors, **apikcloud/apik-addons**) must be referenced as **Git submodules**
inside `/.third-party` for traceability and reproducibility.

### Adding a Submodule (rules & commit policy)

**Rules**
- Place submodules under `/.third-party/<organization>/<repo>`.
- Target the **correct Odoo branch** (e.g. `18.0`, `19.0`).  
- **Pin to a commit** (no floating HEAD) to guarantee deterministic builds.
- Create **symlinks at repository root** to expose only the modules required by the project.
- Commit `.gitmodules`, the submodule path, and the symlinks **together**.

**Examples**
```bash
# OCA example
git submodule add -b 18.0 https://github.com/OCA/account-financial-reporting.git   .third-party/OCA/account-financial-reporting
ln -s ../.third-party/OCA/account-financial-reporting/some_module ./some_module
git add .gitmodules .third-party/OCA/account-financial-reporting ./some_module
git commit -m "chore(submodule): add OCA/account-financial-reporting@18.0 (+ symlink)"

# Apik generic modules (apik-addons) — treated like any third party
git submodule add -b 18.0 https://github.com/apikcloud/apik-addons.git   .third-party/apikcloud/apik-addons
ln -s ../.third-party/apikcloud/apik-addons/apik_generic_module ./apik_generic_module
git add .gitmodules .third-party/apikcloud/apik-addons ./apik_generic_module
git commit -m "chore(submodule): add apikcloud/apik-addons@18.0 (+ symlink)"
```

### Updating Submodules

**Rules**
- Update intentionally; avoid uncontrolled drifts.
- Prefer updating **before a tag** or during maintenance windows.
- Always **pin** the resulting commit (Git records the SHA automatically).

**Examples**
```bash
# Update a single submodule to its remote branch tip
git submodule update --remote --merge .third-party/OCA/account-financial-reporting
git commit -m "chore(submodule): bump OCA/account-financial-reporting"

# Update all submodules following their configured branches
git submodule update --remote --merge
git commit -m "chore(submodules): bump all third-party modules"
```

### Removing Submodules

**Rules**
- Deinit first, then remove from index, then commit.
- **Remove the symlinks** you created at root, in the same PR.

**Example**
```bash
git submodule deinit -f .third-party/OCA/l10n-france
git rm -f .third-party/OCA/l10n-france
git rm -f ./l10n_fr_account  # remove linked module at root
git commit -m "chore(submodule): remove OCA/l10n-france (+ symlink)"
```

### Submodules in Pull Requests (policy & review)

**Author requirements**
- PR title MUST include `submodule` when touching submodules.  
  Example: `chore(submodule): bump OCA/l10n-france to 18.0-<sha>`
- Include a short **changelog** in the PR body (what changed, why, impact).  
- Ensure `.gitmodules`, the submodule path, and the **symlinks** are staged and committed together.
- Provide a link to upstream commits or release notes when available.

**Reviewer checklist**
- Submodule points to the **intended branch** and a **specific commit**.  
- Only **necessary modules** are symlinked at root (no mass‑activation).  
- CI passes (lint, build, tests).  
- No unrelated changes piggybacked.

**CI expectations**
- Build checks the availability of requirements from submodules.  
- Repository compliance verifies submodule placement under `/.third-party` and that symlinks target valid module paths.

---

## Module Placement & Activation (Symlinks)

- **Custom modules** live at the **repository root**.
- **Third‑party modules** (including **apikcloud/apik-addons**) live under `/.third-party/...` and are **never copied** elsewhere.
- Activation is done via **symlinks at repository root** pointing to submodule module paths.

> Everything present at the repository root is available to Odoo.  
> Symlinks allow us to expose only what the project needs, without editing `addons_path`.

Do **not** vendor‑copy external code. Use the **submodule + symlink** pattern.

---

## Odoo.sh Specific Cases

Odoo.sh **supports Git submodules in a hidden folder and symbolic links**. The same approach should be used, rather than the interface provided by the platform. This prevents build failures due to requirements present in submodules that are not automatically satisfied.

---

## Repository Compliance

This configuration may evolve; check the template regularly to ensure compliance.

**Rule**: Any developer contributing to the project must keep this structure intact and required files up to date.  
Divergences must be corrected through a **pull request** and will be reviewed by the Quality team.

---

## Access and Responsibilities

| Role | Responsibility |
|------|----------------|
| **Developer** | Maintains repository structure, submodule state, and symlinks. |
| **Technical Referent** | Validates structural consistency and module organization. |
| **Quality Team** | Ensures compliance with the repository template. |
| **DevOps Team** | Manages permissions, deployment automation, and backups. |
| **Project Manager (PM)** | Coordinates functional validation and client communication. |

All contributors — internal or external — must adhere to the same structure and validation pipeline.


---

# Development Workflow

<mark> Status: Draft — Pending Review and Approval </mark>

> This document describes the development workflow used across all Apik projects.  
> It ensures consistency, traceability, and delivery speed while maintaining high code quality.

## Branching Model

We follow a **trunk-based development** approach:

- `main` is the **only long-lived branch** and represents the current staging environment.
- All developments are made from **short-lived feature branches**:
  ```
  feat/<task>/<short-description>
  ```
  Example:
  ```
  feat/1234/add-invoice-merge-wizard
  ```

- Each branch must be linked to a tracked task for context and traceability.
- Branches are deleted after merge.

## Integration Flow

1. **Create branch** from `main`.  
   Keep it focused on a single feature or fix.

2. **Push regularly** — at least once a day — to keep progress visible and avoid conflicts.

3. **Submit for review** when ready.  
   - Code review by the Quality Team is mandatory.  
   - Exception: **accelerated code delivery** (simple module inclusion, no code change).

4. **Merge into `main`** once validated.  
   This automatically triggers a **staging deployment** (via CI/CD).


## Releases

- Each release (preprod or prod) is tagged in Git:
  ```
  vX.Y.Z
  ```
- Tags serve as version anchors and ensure reproducibility of deployments.
- **Hotfixes** are branched directly from the latest production tag and merged back into `main` afterward.

## Principles

- Keep commits **atomic and meaningful**.
- Avoid long-running branches — merge early, merge often.
- Keep `main` always **deployable**.
- Write code that passes **linting and unit tests** before review.
- Tag only when the deployment is **validated** by the project manager.

## Summary

| Environment | Source | Purpose |
|--------------|---------|----------|
| `main` | staging | Continuous integration branch |
| `feat/*` | from `main` | Feature or fix branch |
| `tag (vX.Y.Z)` | from `main` | Preprod / production release |
| `hotfix/*` | from `tag` | Urgent fix on production |


---

# Commit Guidelines

<mark> Status: Draft — Pending Review and Approval </mark>

> Commits are the smallest and most meaningful unit of change.  
> They tell *why* the code exists, not just *what* was changed.


## Message Convention

We follow the **[Conventional Commits 1.0.0](https://www.conventionalcommits.org/en/v1.0.0/)** specification to keep messages consistent and automatable.

### Syntax

```
<type>(optional scope): <short summary>

[optional body]

[optional footer(s)]
```

**Example**
```
feat(account): add invoice merge wizard

This introduces a new wizard allowing users to merge multiple draft invoices.
Closes #1234
```



## Types

| Type | Meaning | Example |
|------|----------|----------|
| **feat** | New feature | `feat(mail): support DKIM signature` |
| **fix** | Bug fix | `fix(project): avoid crash on archived tasks` |
| **refactor** | Internal code change without changing behavior | `refactor(base): simplify partner search domain` |
| **docs** | Documentation change | `docs: add deployment workflow diagram` |
| **style** | Code style, formatting, missing commas, etc. | `style(account): reformat import wizard` |
| **test** | Add or update tests | `test(project): add regression test for task stages` |
| **chore** | Maintenance or tooling | `chore(ci): upgrade pre-commit hooks` |
| **build** | Changes to build system, dependencies, Docker, etc. | `build(docker): bump Python base image` |
| **perf** | Performance improvement | `perf(account): optimize reconciliation lookup` |
| **ci** | CI/CD config or scripts | `ci(github): parallelize test workflow` |
| **revert** | Revert a previous commit | `revert: fix(account): wrong domain in partner search` |



## Scopes

The **scope** indicates which part of the system is affected — it’s optional but useful when:
- The project is large or modular (ex: Odoo addons, CI, Docker, infra).
- You want to filter commits in changelogs by area.

**Typical scopes**
```
account, project, mail, base, docker, ci, infra, tests, docs
```



## Content Rules

- One logical change per commit (**atomic commits**).  
- Keep the first line under **72 characters**.  
- Explain *why* when the reason isn’t obvious.  
- Avoid vague messages like “update”, “fix issue”, “stuff”.  
- Reference the related ticket if applicable:  
  ```
  feat: add mail alias sync [#1234]
  ```
- Before merging, **squash or rebase** to keep a clean linear history.



## Tips

- Keep the summary short and clear.  
- Use the body to describe context or motivation if needed.  
- Reference issues or tickets with `Closes #1234` or `[AP-456]`.  
- Avoid meaningless messages (“update”, “minor change”, “final”).  
- Consistency is more valuable than perfection.



## Why It Matters

Readable history = faster reviews, clearer changelogs,  
and easier troubleshooting.  
Every commit is a breadcrumb for future developers — leave them useful ones.


---

# Changelog

<mark> Status: Draft — Pending Review and Approval </mark>

This document defines how we **manually** write and maintain changelogs for Apik projects.
It complements our workflow and commits documentations. We follow the principles of [Keep a Changelog 1.1.0](https://keepachangelog.com/en/1.1.0/) who adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html) and write every entry by hand — no auto-generation.



## Purpose & Audience

> The changelog explains **what changed between versions** to people who don’t read commits:
project managers, QA, support, and customers. It focuses on **impact and behavior**, not implementation details.

Project managers don’t review the changelog before release, but they must have **visibility**:
- `CHANGELOG.md` is always available in the main branch.
- Updates are included in release summaries.



## Principles

- **Human-curated**: clarity over automation.
- **Versioned**: entries are grouped by **version tag** (`vX.Y.Z`) and date.
- **Impact-oriented**: include changes users or operators will notice.
- **Neutral tone**: factual, concise, no marketing.
- **Stable format**: consistent sections and phrasing.



## Inclusion Criteria

Include:
- New features or visible improvements.
- Bug fixes with user-visible impact.
- Breaking or behavior-changing updates.
- Migrations, deprecations, removals.
- Performance or security improvements.

Exclude (unless critical):
- Refactors, linting, code style.
- CI, tooling, build-only or dependency bumps.

> If a PM, consultant, or client **needs to know**, it belongs here.



## Structure per Release

```markdown
## [vX.Y.Z] — YYYY-MM-DD

### Added
- …

### Changed
- …

### Fixed
- …

### Deprecated
- …

### Removed
- …

### Performance
- …

### Security
- …

### Migration Notes
- …
```

Optional:
- **Odoo Modules Impacted**: `account`, `project`, `mail`, etc.
- **Known Issues**: short list + workarounds.



## Writing Rules

- **One line per item.**
- **No prefix** ("Added:", "Fixed:") — the section already defines it.
- Start directly with the action or object changed.
- Mention affected **module** in parentheses.
- End with related **ticket ID** in brackets.
- Keep lines under **120 chars**.
- Use strong, descriptive verbs; avoid vague wording.

**Examples (good)**
```markdown
### Added
- Merge wizard for draft invoices (account) [#16838]

### Fixed
- Refreshing price for subscription components (mgdis_sales) [#16838]

### Changed
- Manage rights on Sale Order Templates (mgdis_security) [#16836]
```

**Avoid**
```
- Added: various fixes
- Fixed bug
- Update stuff
```


## Relationship with Commits and Tickets

- **Commits**: technical, atomic, dev-focused.
- **Changelog**: curated, user-focused summary.
- **Tickets**: link the changelog to project tracking tools.

Ticket reference format:
```
(description) [#12345]
```

Example:
```
- Improve invoice PDF header (account) [#17021]
```


## Team Workflow

1. **During development**: developer adds draft changelog lines in the "Unreleased" section.
2. **Before tagging**: *Technical Referent* consolidates and formats entries.
3. **Visibility**: project manager has read access to follow release content.
4. **Tag & publish**: `CHANGELOG.md` committed with the tag.
5. **Post-release**: add known issues if needed; history remains immutable.

**Roles**
- **Developer**: drafts entries.
- **Reviewer (QA)**: checks accuracy and relevance.
- **Technical Referent**: final formatting and scope.



## Odoo-Specific Guidance

- Mention affected **addons** and **models** (e.g., `account.move`, `mail.thread`).
- Flag **data model changes** (fields, constraints, scripts).
- Note **access rights**, **server parameters**, or **env variables** changes.
- Summarize **migration steps**; detailed procedures go in `MIGRATION.md`.



## Template Example

```markdown
# Changelog

All notable changes to this project are documented here.

This changelog follows the [Keep a Changelog 1.1.0](https://keepachangelog.com/en/1.1.0/) convention  
and adheres to Apik’s internal [Changelog Guidelines](https://github.com/apikcloud/docs/docs/07-changelog.md).

The goal: provide a clear, user-focused history of what has changed, improved, or been fixed.

## [v1.5.0] — 2025-10-12

### Added
- Vendor bill OCR with manual fallback (account) [#16838]

### Changed
- Rights management on Sale Order Templates (mgdis_security) [#16836]
- Sum of initial amounts in contract form view (mgdis_contract) [#16838]

### Fixed
- Refreshing subscription component price (mgdis_sales) [#16838]

### Migration Notes
- Update `mgdis_contract` before `mgdis_sales`.
```


## Release Checklist

- [ ] Entries grouped by version and date.
- [ ] Only user-impacting items included.
- [ ] Tone consistent, verbs clear.
- [ ] Security and breaking changes highlighted.
- [ ] Migration notes validated.
- [ ] Changelog committed with the tag.
- [ ] PM has access for visibility.


---

# 8. Migrations Guide

<mark> Status: Draft — Pending Review and Approval </mark>

> This document defines how we document and execute **migrations** between releases at Apik.  
>
> Migrations are critical transitions — they must be **predictable, reversible, and auditable**.


## 1. Purpose & Scope

This guide covers:
- data structure changes between releases,
- dependency updates (Python, addons, Docker image, etc.),
- and post-deployment operations affecting production data.

It does **not** replace the technical SOPs for backups or CI/CD execution,  
but documents the *functional and technical steps* required to ensure a safe transition.



## 2. Principles

- **One migration = one documented process.**
- **Reproducibility first:** every step must be executable on preproduction before production.
- **No hidden logic:** if it’s not written here, it doesn’t exist.
- **Automation when possible**, documentation always.
- **Rollback ready:** any destructive action must include a rollback or safety note.



## 3. When to Document a Migration

A `MIGRATION.md` entry is required when:
- the **data model** changes (fields, constraints, model rename),
- a **manual SQL or server action** is needed,
- a **module rename, merge, or removal** occurs,
- a **new dependency** or **external service** is introduced,
- **environment variables** or **server parameters** change,
- or **functional testing** is required before reactivation.


## 4. Structure of a Migration Entry

Each migration is grouped by target version:

```markdown
## [vX.Y.Z] — YYYY-MM-DD

### Summary
Short overview of what the migration does and why it exists.

### Pre-migration Checklist
- [ ] Backup verified
- [ ] Preproduction updated and validated
- [ ] Rollback plan defined
- [ ] Required modules available
- [ ] Communication with PM scheduled

### Steps
1. Stop cron jobs on the instance.
2. Upgrade affected modules in order:
   - account
   - stock
   - sale
   - custom_module
   
3. Run manual SQL commands:

   UPDATE account_move SET state='draft' WHERE ...;
   
4. Clear caches and restart Odoo.
```

### Migration Command Script

Each migration must include an executable `migrate.sh` script containing the list of commands to be used, most often the installation or update of modules.
This script acts as the canonical reference for what has been executed in preproduction and production.

These commands are intentionally **human-maintained**, not generated automatically.

Example template:

```bash
#!/usr/bin/env bash
# MIGRATION COMMANDS — run sequentially on preproduction, then on production.

odoo --stop-after-init --no-http -i <module_x>
odoo --stop-after-init --no-http --i18n-overwrite -u <module_y>,<module_z>
```

Guidelines:
- Always include the exact commands used for **preproduction** and **production** runs.
- Each command should be **copy-paste ready** and executable in the deployment environment.
- Use the `--stop-after-init` and `--no-http` flags to prevent server startup during upgrades.
- Prefer one command per module for clarity and rollback tracking.
- Validate the same command sequence in preproduction before applying it to production.

### Post-migration Actions
- [ ] Rebuild mail index
- [ ] Reassign activities
- [ ] Revalidate scheduled actions
- [ ] Test core features (list them)

### Rollback Procedure
Explain how to restore from backup or undo a partial migration.

### Validation
The migration is considered complete when:
- Data integrity is verified,
- No blocking errors remain in logs,
- Functional tests have passed,
- The **Technical Referent** validates the release.


## 5. Roles

| Role | Responsibility |
|------|----------------|
| **Developer** | Writes and tests migration steps locally |
| **Technical Referent** | Reviews and approves the migration procedure |
| **Project Manager (CP)** | Validates functional readiness and client communication |
| **Hosting Team** | Executes migrations on staging and production |


## 6. Location and Versioning

- The file `MIGRATION.md` lives at the project root.  
- Each release with a migration must include its own section.
- Never rewrite or delete a past migration — add a new one instead.
- The changelog links to this file when migration steps are required.

Example in `CHANGELOG.md`:
```markdown
### Migration Notes
See detailed steps in [MIGRATION.md](./MIGRATION.md) for v1.5.0.
```


## 7. Tips for Odoo Projects

- Always test migrations on a **copy of the production database**.
- Use `--stop-after-init` to perform schema upgrades safely.
- For large data updates, prefer **server actions or SQL batches** with commit checkpoints.
- If custom addons modify `ir.model.fields`, export before migration.
- Record migration duration and anomalies in an internal note.


---

# Python Examples

This document lists common coding patterns with **Bad** and **Good** examples.  
Each example includes a short explanation of why the good version is preferred.


## 1. Clear variable naming

**Don't**
```python
x = 12
y = 24
z = x + y
print(z)
```

**Do**
```python
width = 12
height = 24
area = width + height
print(area)
```

**Explanation:**  
Variable names should describe intent. Readers should not have to guess what `x` means.


## 2. Avoid duplicated code

 **Don't**
```python
if status == "done":
    print("Task done")
if status == "pending":
    print("Task pending")
```

 **Do**
```python
messages = {"done": "Task done", "pending": "Task pending"}
print(messages.get(status, "Unknown"))
```

**Explanation:**  
Duplicated logic increases maintenance cost. Use data structures to centralize behavior.


## 3. Use context managers

 **Don't**
```python
file = open("data.txt", "r")
data = file.read()
file.close()
```

 **Do**
```python
with open("data.txt", "r") as file:
    data = file.read()
```

**Explanation:**  
`with` ensures the file is properly closed even if an exception occurs.


## 4. Explicit is better than implicit

 **Don't**
```python
def calc(a, b, op="+"):
    return eval(f"{a}{op}{b}")
```

 **Do**
```python
def calc(a, b, op="+"):
    if op == "+":
        return a + b
    if op == "-":
        return a - b
    raise ValueError("Unsupported operator")
```

**Explanation:**  
Avoid `eval()` and implicit behavior. Explicit logic improves readability and security.


## Rule of thumb

> Prefer **clarity over cleverness**.  
> Good code explains itself — bad code needs an interpreter.


---

# Odoo Code Quality Examples (Bad vs Good)

Each example shows a **Bad** and a **Good** pattern with a brief rationale.



## 1. ORM: avoid raw SQL when ORM suffices
 **Don't**
```python
self.env.cr.execute("UPDATE sale_order SET state='done' WHERE id=%s", (order.id,))
```
 **Do**
```python
order.write({"state": "done"})
```
**Why:** ORM handles metadata, audits, computed fields, and access rules. Raw SQL bypasses them. [Ref: Coding Guidelines, ORM API]



## 2. Computed fields: declare dependencies and store when needed
 **Don't**
```python
total = fields.Monetary(compute="_compute_total")

def _compute_total(self):
    for rec in self:
        rec.total = sum(l.price_total for l in rec.line_ids)
```
 **Do**
```python
total = fields.Monetary(compute="_compute_total", store=True)
@api.depends("line_ids.price_total")
def _compute_total(self):
    for record in self:
        record.total = sum(record.line_ids.mapped("price_total"))
```
**Why:** `@api.depends` ensures correct recompute; `store=True` if used in search/sort. [Ref: ORM API]



## 3. Fields naming in compute methods: use `record` or `records`, not `sales`, `partners`, etc.
 **Don't**
```python
def _compute_total(self):
    for sale in self:
        sale.total = sum(line.price_total for line in sale.line_ids)
```
 **Do**
```python
def _compute_total(self):
    for record in self:
        record.total = sum(line.price_total for line in record.line_ids)
```
**Why:** Generic names avoid confusion in reused code. [Ref: Coding Guidelines]

## 3. Security: don’t use `sudo()` casually
 **Don't**
```python
records = self.sudo().search([("partner_id", "=", partner.id)])
```
 **Do**
```python
records = self.search([("partner_id", "=", partner.id)])
# If you *must* elevate, narrow scope and document why:
secure_records = self.sudo().browse(safe_ids)
```
**Why:** `sudo()` bypasses ACLs/record rules; restrict it to minimal scope. [Ref: Security]



## 4. Constraints: use `_check_*` or SQL constraints over `onchange` for data integrity
 **Don't**
```python
@api.onchange("qty")
def _onchange_qty(self):
    if self.qty < 0:
        self.qty = 0
```
 **Do**
```python
qty = fields.Float()
_sql_constraints = [("qty_nonneg", "CHECK(qty >= 0)", "Quantity must be non-negative.")]
@api.constrains("qty")
def _check_qty(self):
    if any(r.qty < 0 for r in self):
        raise ValidationError("Quantity must be non-negative.")
```
**Why:** Onchange is UI-only; constraints protect data server-side. [Ref: ORM API]



## 5. Views: use XML inheritance (`xpath`) rather than copy-pasting entire views
 **Don't**
```xml
<record id="view_form_partner_custom" model="ir.ui.view">
  <field name="arch" type="xml">
    <!-- Copied full form view here -->
  </field>
</record>
```
 **Do**
```xml
<record id="view_form_partner_inherit_custom" model="ir.ui.view">
  <field name="inherit_id" ref="base.view_partner_form"/>
  <field name="arch" type="xml">
    <xpath expr="//group[@name='contact']" position="inside">
      <field name="x_trust_score"/>
    </xpath>
  </field>
</record>
```
**Why:** Inheritance is robust to upstream changes and reduces churn. [Ref: Views / View records]



## 6. External IDs & data files: stable `xml_id`, `noupdate`, and references
 **Don't**
```xml
<record id="tmp_partner_tag" model="res.partner.category"> ... </record>
```
 **Do**
```xml
<!-- data/tags.xml -->
<data noupdate="1">
  <record id="partner_tag_vip" model="res.partner.category">
    <field name="name">VIP</field>
  </record>
</data>
```
**Why:** Stable `xml_id` and `noupdate="1"` prevent accidental updates on re-install; makes refs with `env.ref()` reliable. [Ref: Developer docs]


## 7. Context and defaults: avoid globals, use lambdas with env
 **Don't**
```python
default_company_id = fields.Many2one("res.company", default=self.env.company.id)
```
 **Do**
```python
company_id = fields.Many2one("res.company", default=lambda self: self.env.company.id)
```
**Why:** Defaults must be callables to get the *current* env and user/company. [Ref: ORM API]


## 8. Precision for monetary/float comparisons: use helpers
 **Don't**
```python
if rec.amount_total == 0.0:
    ...
```
 **Do**
```python
from odoo.tools.float_utils import float_is_zero
if float_is_zero(rec.amount_total, precision_rounding=rec.currency_id.rounding):
    ...
```
**Why:** Respect currency precision; avoid equality on floats. [Ref: ORM API / tools]


## 9. Domain filtering: prefer domain searches to Python filtering
 **Don't**
```python
orders = self.search([])
paid = orders.filtered(lambda o: o.state == "paid")
```
 **Do**
```python
paid = self.search([("state", "=", "paid")])
```
**Why:** Domains push work to the database; better performance and less memory. [Ref: ORM API]



## 10. Translations: use `_()` and avoid string concatenation
 **Don't**
```python
raise UserError("Order " + self.name + " is invalid")
```
 **Do**
```python
from odoo import _
raise UserError(_("Order %s is invalid") % self.name)
```
**Why:** Mark strings for i18n; avoid concatenation to keep messages translatable. [Ref: Coding Guidelines]



## 11. API decorators: match the method’s calling convention
 **Don't**
```python
def create(vals):
    ...
```
 **Do**
```python
@api.model
def create(self, vals):
    return super().create(vals)
```
**Why:** Decorators (`@api.model`, `@api.depends`, etc.) declare expectations and enable framework features. [Ref: ORM API]



## 12. Access rules over custom code
 **Don't**
```python
def _can_see(self):
    if self.env.user.login.endswith("@vip.com"):  # brittle
        return True
    return False
```
 **Do**
```text
# security/ir.model.access.csv + record rules on the model
```
**Why:** Use ACLs and record rules for data access; keeps security declarative and reviewable. [Ref: Security]


---

# The Apik Way

---

<p align="center">
  <img src="_media/compass.png" alt="Apik Logo" width="500">
</p>

## Purpose

This document sets the principles that shape our engineering culture.  
It translates our collective values into practical expectations for developers, Technical Referents, and the Quality team.

It is not a manifesto.  
It is a framework — a set of commitments that help us deliver stable, transparent, and ethical systems.


## Our Commitments

Each developer commits to:

- producing code that is reliable, readable, and maintainable;
- adhering to shared rules and established best practices;
- clearly documenting any complex portion of code;
- making their work easy to review and understand;
- considering and applying feedback received, especially during code reviews, with a mindset of continuous improvement;
- helping teammates whenever possible, fostering a culture of support and knowledge sharing;
- resisting shortcuts and challenging outdated habits;
- anticipating potential performance and stability impacts;
- evolving their practices in line with Python recommendations and Odoo ecosystem developments;
- reporting identified risks or uncertainties;
- contributing to the improvement and ongoing update of this manifesto;
- sharing discoveries, ideas, and insights in a spirit of collective growth;
- using all available tools — including AI-based ones — responsibly and thoughtfully;
- maintaining full control over any automatically generated code.


## Document Organization

> **Working language:** All code, comments, commit messages, and documentation are written in **English**.
 
<mark>Some parts are stabilized, others are still drafted.</mark>

Each section is divided into:
- **Strict rules** — mandatory principles to be followed in all circumstances,  
- **Implementation recommendations** — expected best practices, which can only be bypassed in exceptional and documented cases.

Examples, diagrams, and code snippets are included where relevant to illustrate common patterns or expected structures.


## Partners

All developers — internal or external — are expected to follow Apik’s development charter and coding standards.

External partners operate under the same rules and undergo the same validation process by the Technical Referent and the Quality team.


---

# CI/CD

*Content to be written: CI/CD pipelines, quality gates, release process.*

---

# Code Review Guidelines

<mark> Status: Draft — Pending Review and Approval </mark>

> All code changes at Apik are subject to **systematic review** before being merged into `main`.  
> The review is a key element of quality assurance, technical coherence, and team learning.

## Purpose

Code review ensures that every line of code entering production is:
- **Correct** — functionally aligned with the ticket or feature goal,
- **Consistent** — following Apik’s internal development charter,
- **Maintainable** — clear, tested, and logically structured,
- **Secure** — free from obvious vulnerabilities or unsafe shortcuts.

It is also a means of **shared ownership**: reviewers understand the code they approve.


##  Scope and Exceptions

### Mandatory Reviews
- All **feature branches** (`feat/<ticket>/<desc>`)
- All **bug fixes** (`fix/<ticket>/<desc>`)
- Any **refactor or technical improvement** that impacts shared components.

### Exceptions — “Accelerated Code Delivery”
A review can be skipped *only* for:
- Urgent production hotfixes that are **risk-assessed** by the Technical Referent.
- Integrations of **third-party modules** without internal modifications.

In such cases, the Technical Referent must **retro-review** the code after deployment  
and document the exception in the project’s changelog.


## Roles

| Role | Responsibility |
|------|----------------|
| **Developer (author)** | Opens the PR, provides clear context, responds to feedback |
| **Reviewer** | Checks code quality, style, performance, and maintainability |
| **Technical Referent** | Final approver; validates the merge to `main` |
| **QA (optional)** | Tests functional behavior when relevant |

A pull request must have at least **one approval** from a Technical Referent or an assigned reviewer before merge.


## Review Process

### Step 1 — Prepare the Review
- Rebase your branch on the latest `main` (`git fetch && git rebase origin/main`).
- Ensure all tests pass locally and pre-commit checks succeed.
- Squash your commits if necessary (see `COMMITS.md`).
- Open a Pull Request with:
  - a descriptive title (feature or fix),
  - a clear summary of purpose and impact,
  - reference to the ticket ID (`[#12345]`).

### Step 2 — Conduct the Review
Reviewers must:
- Read the code, not just the diff — understand intent.
- Focus on *why* and *how*, not personal style preferences.
- Check:
  - Functionality and regressions
  - Performance implications
  - Security / data exposure
  - Test coverage (existing or new)
  - Naming, clarity, and comments
  - Compliance with Apik’s code style and guidelines

Optional tools:
- `ruff`, `pylint-odoo`, and pre-commit hooks (should pass before review).
- Odoo run logs and functional testing in dev/staging.

### Step 3 — Feedback & Collaboration
- Keep feedback **constructive and concise**.
- Prefer **suggestions over imperatives**.
- If unsure, ask for clarification — don’t block unnecessarily.
- The author is responsible for addressing feedback and re-requesting review.


## Merge Rules

- **Merges to `main` are done via “Squash & merge” or “Rebase and merge”**.
- The final commit message must follow the [Conventional Commits](./COMMITS.md) format.
- No merge commits (`--no-ff` merges are forbidden).
- Branches must be rebased before merge to ensure linear history.
- The Technical Referent has the **final say** on whether the branch is ready.

A merge means:
> “This feature is ready for staging and may be deployed.”


## Review Quality Criteria

A review is considered complete when:
- All discussions are resolved.
- Code style and conventions are respected.
- Tests (unit or functional) are in place or justified.
- The reviewer can explain the purpose of the change.

Avoid “rubber-stamping”: every approval must be **an informed decision**.


## Review Etiquette

- Assume good intent.
- Praise what’s well done before noting improvements.
- Separate factual issues from opinions.
- Don’t block indefinitely; escalate to the Technical Referent if needed.
- Use draft PRs for early feedback — not everything must be final.


## Common Review Findings (to watch for)

- Missing or incorrect access rights in Odoo models.
- SQL queries without limits or context filters.
- Overridden core methods without calling `super()`.
- Unused imports, dead code, or debug prints.
- Missing dependency in `__manifest__.py`.
- Lack of `@api.constrains` or `@api.depends` when needed.
- Hardcoded strings instead of translations.


## Checklist for Reviewers

- [ ] Code runs without errors locally.
- [ ] Changes follow naming and structure rules.
- [ ] No sensitive data or credentials in code.
- [ ] Commit message and PR description are clear.
- [ ] Tests (if any) cover critical paths.
- [ ] No unnecessary dependencies added.
- [ ] Code readability and clarity are acceptable.
- [ ] Ticket reference included.


---

# Environment Setup

<mark> Status: Draft — Pending Review and Approval </mark>

> This document provides guidelines for setting up the development environment for Apik projects.

## Getting Started (Developers)

### Prerequisites
- Git ≥ 2.40 with submodule support
- Docker / Docker Compose
- Python 3.11 (for tooling), `pip`
- (Optional) VS Code + Dev Containers extension

### Clone & bootstrap
```bash
# Clone the project
git clone git@github.com:apikcloud/client-repo.git
cd client-repo

# Pull third‑party code
git submodule update --init --recursive

# Install pre-commit hooks
pip install -U pre-commit
pre-commit install
```

### Dev container (recommended)
Open the folder in VS Code and **Reopen in Container**. Tooling and linters are preconfigured.

### Run Odoo locally (minimal)
Use the project’s Docker compose or helper scripts if provided. Example:
```bash
# Example only — adjust to your project scripts
docker compose up -d
docker compose logs -f odoo
```

> Third‑party addons are included as **submodules** in `/.third-party` and exposed via **symlinks at the repository root**. Anything at the root is visible to Odoo; no need to edit `addons_path`.

### Commit rules (must‑read)
- Conventional Commits; see [`docs/06-commits.md`](./docs/06-commits.md)
- One PR per feature; code review required; see [`docs/XX-code-review.md`](./docs/XX-code-review.md)
- Keep changelog human‑written; see [`docs/07-changelog.md`](./docs/07-changelog.md)



---

# Odoo Major Version Changes

<mark> Status: Draft — Pending Review and Approval </mark>

> This document summarizes **key technical and functional changes** introduced in major Odoo versions.  
> It is designed to help developers, integrators, and Technical Referents anticipate migration impacts and adjust their codebase accordingly.

[Official Odoo changelogs](https://www.odoo.com/documentation/19.0/fr/developer/reference/backend/orm/changelog.html#)



## General Principles

- Odoo releases a **major version every year**, typically in October.
- Each version is supported for **three years** under Odoo Enterprise.
- Upgrades between major versions may require **database migration**, **code adaptation**, and **infrastructure updates**.
- Minor releases are backward-compatible and primarily include bug fixes or small enhancements.



## Evolution Summary

| Version | Year | Key Technical Changes | Key Functional Changes |
|----------|------|-----------------------|-------------------------|
| **v15 → v16** | 2022 | - ORM performance overhaul<br>- New “models.Command” syntax for relational fields<br>- Removal of legacy API decorators<br>- Mass refactor of list and kanban views<br>- Switch to OWL 2 framework for frontend | - Accounting refactor (no longer a community module)<br>- Improved POS and Inventory<br>- Consolidated settings UI |
| **v16 → v17** | 2023 | - OWL 2 adoption completed (100% frontend)<br>- New JavaScript module loader (ESM)<br>- RPC and webclient refactored<br>- Removal of jQuery and legacy JS framework<br>- New testing utilities for JS<br>- Split of web modules (web, web_editor, mail, spreadsheet) | - New interface design (modern theme)<br>- Unified search and navigation bar<br>- Improved CRM and sales flow<br>- Better Excel import/export |
| **v17 → v18** | 2024 | - OWL 3 (hooks, stores, and reactive components)<br>- New asset bundling with `rollup`<br>- Backend actions refactor (async jobs)<br>- Changes to mail/thread models (new chatter API)<br>- Refactored ORM caches and environment handling<br>- Base HTTP routing simplified | - Major UX simplifications<br>- New Kanban view editor<br>- Improved Studio compatibility<br>- Enhanced website & ecommerce flows |
| **v18 → v19** | 2025 | - Introduction of async ORM methods<br>- Refactor of Odoo’s internal CLI and test runner<br>- Removal of `api.multi` remnants<br>- PostgreSQL 15+ requirement<br>- Stricter manifest validation and metadata structure | - Modernized UI (single-page feel)<br>- Multi-company refinements<br>- Extended data migration tooling |

## 19.0

> [Odoo 19 Release Notes](https://www.odoo.com/fr_FR/odoo-19-release-notes)

### SQL constraints

Old way:
```python
_sql_constraints = [
        (
            "product_uniq",
            "unique(parent_product_id, product_id)",
            "Product must be only once on a pack!",
        ),
    ]
 
```

New way:
```python
_product_uniq = models.Constraint(
        "unique(parent_product_id, product_id)",
        "Product must be only once on a pack!",
    )
```


---

# 10. Module Guidelines

<mark> Status: Draft — Pending Review and Approval </mark>

> This section covers guidelines specific to Odoo addons developed by Apik. It includes naming conventions, module structure, manifest requirements, model definitions, field usage, and method implementations.

## 1. Naming Conventions

### Rules

- **Addon names**: `apik_` prefix for all Apik-specific addons (e.g., `apik_brand`, `apik_filter`)
- **File headers**: All files include copyright header: `# Copyright 2025 apik (https://apik.cloud).`

## 2. Structure Pattern

All addons follow standard Odoo structure with Apik-specific conventions:
```
addon_name/
├── __init__.py           # Import models, controllers, wizards
├── __manifest__.py       # Standard Odoo manifest with Apik metadata
├── controllers/          # HTTP controllers (website addons)
├── i18n/                 # Translation files
├── models/               # Business logic models
├── security/             # ir.model.access.csv, security groups
└── static/               # Assets: JS, CSS, images
    └── src/js/           # JavaScript modules using @odoo-module
├── views/                # XML view definitions  
├── wizards/              # Transient models for wizards
```

## 3. Manifest Guidelines

### Manifest Structure
Follow this pattern for `__manifest__.py` in all Apik addons:
```python
# Copyright 2025 apik (https://apik.cloud).
# License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl).

{
    "name": "Descriptive Name",
    "summary": "A brief summary of the module's purpose",
    "version": "18.0.1.0.0",
    "category": "Category/Subcategory", 
    "author": "Apik",
    "maintainers": ["<github_username>"],
    "website": "https://apik.cloud",
    "depends": [
        "base", 
        "other_modules",
    ],
    "data": [
        # Order alphabetically, if possible.
        # Data
        # Reports  
        # Security
        "security/ir.model.access.csv",
        # Templates
        # Wizards, before views because views can depend on wizards.
        # Views
        "views/model_name.xml",
        # Menus, after all other elements as menu links mostly depend on them.
    ],
    "assets": {
        "web.assets_frontend": [
            "addon_name/static/src/js/file.js"
        ]
    },
    "installable": True,
    "auto_install": False,
    "application": False,
    "license": "LGPL-3",
}
```

**Rules:**
- The `name` field must be unique across all addons.
- The `summary` field should provide a concise description of the module's functionality.
- The `version` field must follow the semantic versioning format (MAJOR.MINOR.PATCH).
- The `category` field should accurately reflect the module's purpose and functionality.
- The `author` field must be set to "Apik".
- The `maintainers` field must include the GitHub usernames of all maintainers.
- The `website` field must point to the official Apik website.
- The `depends` field must list all required modules, including `base`.
- The `data` field must include all necessary XML files, ordered alphabetically.
- The `assets` field must include all required JavaScript files.
- The `installable`, `auto_install`, `application`, and `license` fields must be set as shown in the example.


- **License**: All addons use `LGPL-3` license

## 4. Models

This document defines **how to design, name, and organize models** in Odoo addons.  
It complements the pages on **Methods** and **Fields**.

---

### 1. Model Types (and when to use them)

| Type | Base Class | Purpose | Typical Use |
|------|------------|---------|-------------|
| **Persistent** | `models.Model` | Stored business data | Partners, orders, invoices |
| **Transient** | `models.TransientModel` | Ephemeral wizards; auto‑cleaned | Assistants, import/export dialogs |
| **Abstract** | `models.AbstractModel` | Share behavior via inheritance (no table) | Mixins, reusable behaviors, e.g. `mail.thread`, `mail.activity.mixin`, `portal.mixin` |


**Rules**
- Use **TransientModel** if data should **not** survive garbage collection.
- Use **AbstractModel** for **behavior reuse**, not for storing data.
- Prefer **mixins** over re‑implementing generic features (mail, portal, sequence, rating).

---

### 2. Naming Conventions

#### 2.1 Technical Model Name (`_name`)

- Use **namespace prefix** of your addon: `your_addon.model_name`.
- Use **singular nouns** for entities (`sale.order`, `account.move`, `product.brand`).
- Keep it **short and descriptive** (under ~40 chars).

**Examples**
```python
_name = "product.brand"
_name = "move.chatter.history"
```

#### 2.2 Python Class Name

- Use **CapWords** (PEP 8): `Contract`, `SalesSubscription`.

~~When inheriting existing models via `_inherit`, keep the class name meaningful, not necessarily identical to `_name`.~~

#### 2.3 Display Name and Ordering

- Set `_rec_name` if the default `name` is not the correct label.
- Set `_order` for deterministic listing (avoid slow expressions).

**Example**
```python
_rec_name = "display_name"
_order = "date_start desc, id desc"
```

---

### 3. Inheritance Models

#### 3.1 Classical Inheritance (`_inherit`)

Extends an existing model (same table).  
Use to add fields/behavior without changing identity.

```python
class ResPartner(models.Model):
    _inherit = "res.partner"

    loyalty_points = fields.Integer(default=0)
```

**Rules**
- Keep overrides **thin**; delegate logic to helpers.
- Document functional intent in a short class docstring.

#### 3.2 Delegation Inheritance (`_inherits`)

Composes another model via foreign key (separate tables).  
Use when your model **is‑a** + **has‑a** relationship is required.

```python
class LibraryMember(models.Model):
    _name = "library.member"
    _inherits = {"res.partner": "partner_id"}

    partner_id = fields.Many2one("res.partner", required=True, ondelete="cascade")
```

**Rules**
- Choose `_inherits` when you need partner fields **and** your own identity/table.
- Keep FK field names explicit: `<model>_id` (e.g., `partner_id`).

#### 3.3 Abstract Models

Provide behavior and constraints without a table.

```python
class Exportable(models.AbstractModel):
    _name = "apik.exportable"
    _description = "Export helpers"
```

**Rules**
- No stored fields except computed helpers without storage.
- Keep API **stable**; treat like a public contract for your addon.

---

### 4. Class Layout (ordering & sections)

Keep a **consistent block order** inside every model class:

1. **Meta**: `_name`, `_description`, `_inherit`/`_inherits`, `_rec_name`, `_order`  
2. **Defaults**: default values for fields  
3. **Fields**: simple → relational → computed  
4. **SQL constraints**: `_sql_constraints`  
5. **Methods**: all methods, see **XX-Methods** for details

**Example skeleton**
```python
class Contract(models.Model):
    _name = "apik_contract.contract"
    _description = "Contract"

    # 2) Fields
    name = fields.Char(required=True, index=True)
    partner_id = fields.Many2one("res.partner", required=True, ondelete="restrict")
    date_start = fields.Date(required=True)
    date_end = fields.Date()
    amount_total = fields.Monetary(currency_field="currency_id")
    currency_id = fields.Many2one("res.currency", required=True)
    state = fields.Selection([("draft","Draft"),("active","Active"),("closed","Closed")], default="draft")

    # 3) SQL constraints
    _sql_constraints = [
        ("date_range_ok", "CHECK(date_end IS NULL OR date_end >= date_start)", "End date must be after start date."),
        ("name_unique_partner", "unique(name, partner_id)", "Contract name must be unique per partner."),
    ]

    # 4) Python constraints
    @api.constrains("date_start", "date_end")
    def _check_dates(self):
        for rec in self:
            if rec.date_end and rec.date_end < rec.date_start:
                raise ValidationError("End date must be after start date.")

    # 5) Compute
    @api.depends("line_ids.amount")
    def _compute_amount_total(self):
        for rec in self:
            rec.amount_total = sum(rec.line_ids.mapped("amount"))

    # 7) Business methods
    def action_activate(self):
        self.filtered(lambda r: r.state == "draft").write({"state": "active"})
        return True

    # 8) Overrides
    def write(self, vals):
        res = super().write(vals)
        self._log_state_change(vals)
        return res

    # 9) Helpers
    def _log_state_change(self, vals):
        if "state" in vals:
            _logger.info("Contract %s changed to %s", self.ids, vals["state"])
```

---

### 5. Data Integrity & Constraints

- Prefer **SQL constraints** for invariants that must hold at DB level (uniqueness, date logic).  
- Use `@api.constrains` for Python‑level checks needing record context.  
- Use **ondelete policies** (`restrict`, `cascade`, `set null`) explicitly on relational fields.  
- Avoid storing denormalized values unless justified (and document why).

---

### 6. Security & Access (high‑level)

- Define `ir.model.access.csv` for create/read/write/unlink rules per role.  
- Use **record rules** for domain‑based access; keep them **as simple as possible**.  
- Never filter security entirely in Python — **enforce in ACLs and rules**.

---

### 7. Internationalization

- Use `_(...)` for all user‑visible strings (labels, errors).  
- Keep field help/tooltips concise and actionable.

---

### 8. Performance Considerations

- Avoid per‑record loops in computed fields — batch with `mapped()` or set comprehensions.  
- Prefetch relations and use `read_group` for aggregates.  
- Index frequently searched fields (`index=True`).  
- Avoid large `@api.depends` lists; depend only on what’s necessary.

---

### 9. Do & Don’t

**Do**
- Keep model names clear and stable.  
- Document non‑obvious design choices in a class docstring.  
- Choose `_inherits` for composition scenarios.  
- Keep overrides thin; delegate to helpers.

**Don’t**
- Don’t overload models with unrelated concerns — split into separate addons.  
- Don’t store transient UI state on persistent models.  
- Don’t hide cross‑module dependencies; declare them in `__manifest__.py`.  
- Don’t rely on implicit defaults; be explicit.

---
## 5. Fields

This document defines how to **design, name, and configure fields** in Odoo addons.  
It complements the pages on **Models** and **Methods**.

---

### 5.1. Field Types (quick map)

| Category | Types | Notes |
|---------|------|-------|
| **Basic** | `Char`, `Text`, `Html`, `Boolean`, `Integer`, `Float`, `Date`, `Datetime`, `Binary` | Prefer `Char(index=True)` for searchable short strings |
| **Money & Numbers** | `Monetary`, `Float`, `Integer` | `Monetary` requires `currency_field` |
| **Relational** | `Many2one`, `One2many`, `Many2many` | Always set `comodel_name`; define `ondelete` for `Many2one` |
| **Selection** | `Selection` | Keep choices stable; use constants |
| **Specialized** | `Json`, `Reference` | Use sparingly; document the schema clearly |

---

### 5.2. Naming & Labels

- **Technical name**: `snake_case`, short, descriptive (`amount_total`, `partner_ref`).  
- **String/label**: concise, user‑facing, **translated** (`string="Amount Total"`).  
- **Help**: add `help="..."` for non‑obvious fields; short and actionable.  
- **Copy**: set `copy=False` for fields that should not duplicate on record copy (e.g., states, numbers).

**Example**
```python
amount_total = fields.Monetary(string="Total", currency_field="currency_id", help="Computed total in order currency.")
```

---

### 5.3. Relational Fields

#### Many2one
```python
partner_id = fields.Many2one(
    comodel_name="res.partner",
    index=True,
    ondelete="restrict",
    required=True,
    string="Customer",
)
```
**Rules**
- Always specify `ondelete`: choose among `restrict`, `set null`, `cascade` (be explicit).  
- Add `index=True` on frequently searched relations.  
- Use meaningful names: `<model>_id` (e.g., `company_id`, `currency_id`).

#### One2many
```python
line_ids = fields.One2many(comodel_name="apik_contract.line", copy=True, inverse_name="contract_id", string="Lines")
```
**Rules**
- `inverse_name` must exist and be indexed if used in domains/aggregations.  
- Avoid massive onchanges triggered by large O2M; prefer explicit buttons or batches.

#### Many2many
```python
tag_ids = fields.Many2many("apik_contract.tag", string="Tags")
```
**Rules**
- Avoid M2M for data that needs ordering or extra attributes → use **O2M with detail model**.  
- When performance matters, ensure joins are selective (domains, indices on comodel).

---

### 5.4. Computed, Inverse, and Related

#### Computed
```python
amount_total = fields.Monetary(compute="_compute_amount", store=True, currency_field="currency_id")

@api.depends("line_ids.amount", "currency_id")
def _compute_amount(self): ...
```
**Rules**
- Use `store=True` for values frequently used in searches/aggregations or displayed in lists.  
- Keep `@api.depends(...)` **minimal and accurate** to reduce invalidations.  
- Prefer **batch computation**; avoid per‑record loops.  
- Use `compute_sudo=True` only if strictly necessary and documented.

#### Inverse
Provide an inverse when users can edit a computed field and you need to **persist** that edit.
```python
rate = fields.Float(compute="_compute_rate", inverse="_inverse_rate", store=True)
def _inverse_rate(self): ...
```

#### Related
```python
company_currency_id = fields.Many2one(related="company_id.currency_id", store=True)
```
**Rules**
- Use `related` for 1‑to‑1 derivations; add `store=True` if used in search/sort.  
- Do not chain long `related` paths; compute with a helper instead.

---

### 5.5. Selections & Enums

```python
STATE = [
    ("draft", "Draft"),
    ("active", "Active"),
    ("closed", "Closed"),
]

state = fields.Selection(
    selection=STATE,
    string="Status",
    default="draft",
    tracking=True,
    index=True,
    required=True,
)
```
**Rules**
- Keep choices **stable** (changing keys breaks data/migrations).  
- Centralize options as **module‑level constants**.  
- Use `tracking=True` for user‑visible lifecycle fields.

---

### 5.6. Money, Currency, and Precision

```python
currency_id = fields.Many2one("res.currency", string="Currency", required=True, ondelete="restrict")
amount_total = fields.Monetary(currency_field="currency_id", string="Total", digits="Product Price")
```
**Rules**
- Always provide `currency_field` for `Monetary`.  
- Use **named precisions** (`digits="Product Price"`) where business rules require it.  
- Avoid storing both **unit price** and **total** without justification; derive when possible.

---

### 5.7. Defaults, Readonly, Copy, Tracking

- `default=...` for safe defaults (functions allowed).  
- `readonly=True` for values users must not edit; pair with `states={...}` if needed.  
- `copy=False` for identifiers/sequences or transient state.  
- `tracking=True` on important business fields; use sparingly to avoid log noise.

---

### 5.8. Indexing & Searchability

- Add `index=True` on fields frequently used in domains or joins.  
- For text search, combine `index=True` on `Char` + a **search** helper if needed.  
- Use `read_group` for aggregations; avoid scanning large tables via Python.

---

### 5.9. Security & Multicompany

- Do **not** rely on Python to enforce access; define **ACLs** and **record rules**.  
- For multicompany fields, consider `company_dependent=True` or explicit company FK.  
- Validate cross‑company relations in `@api.constrains` when relevant.

---

### 5.10. Internationalization

- All `string`, `help`, and selection labels must be **translatable**.  
- Keep messages short and clear; avoid jargon in user‑facing labels.

---

### 5.11. Migrations & Stability

- Renaming a field breaks stable APIs; prefer **new field + migration** over renames.  
- When deprecating, keep the old field read‑only for a version and provide a data script.  
- Document all changes in `MIGRATIONS.md` and reference them in the changelog.

---

### 5.12. Do & Don’t

**Do**
- Use explicit `ondelete` on `Many2one`.  
- Batch compute; keep `@api.depends` minimal.  
- Track important lifecycle fields with `tracking=True`.  
- Centralize selections in constants.

**Don’t**
- Don’t use `Json` as a shortcut for unmodeled data when relations suffice.  
- Don’t overuse `related` with long chains — compute instead.  
- Don’t store redundant denormalized data without justification.  
- Don’t hide business logic in field defaults.

---

**Examples (balanced pattern)**
```python
class PartnerContract(models.Model):
    _name = "partner.contract"
    _description = "Partner Contract"

    name = fields.Char(index=True, required=True, string="Name")
    partner_id = fields.Many2one("res.partner", string="Customer", required=True, index=True, ondelete="restrict")
    currency_id = fields.Many2one("res.currency", string="Currency", required=True, ondelete="restrict")

    line_ids = fields.One2many(comodel_name="partner.contract.line", inverse_name="contract_id", copy=True)

    amount_total = fields.Monetary(string="Total", currency_field="currency_id", compute="_compute_amount", store=True)
    state = fields.Selection(selection=STATE, string="Status", default="draft", tracking=True, index=True, required=True)

    @api.depends("line_ids.amount")
    def _compute_amount(self):
        for record in self:
            record.amount_total = sum(record.line_ids.mapped("amount"))
```

## 6. Methods

This document defines **how to design, name, and order methods** in Odoo modules.  
It applies to both business logic and framework-level code.

---

### 6.1. Method Types in Odoo

#### Business Methods
These implement the functional logic of your module (invoicing, validation, etc.).  
They are typically **called by actions, buttons, or cron jobs**.

**Example**
```python
def action_validate(self):
    """Validate the invoice and trigger posting logic."""
    self.ensure_one()
    self._check_invoice_balanced()
    self.state = "posted"
    self._post_account_move()
```

**Rules**
- Use descriptive verbs (`action_`, `generate_`, `export_`, `import_`).
- Must be **idempotent** when possible (safe to call twice).
- Should **not mix UI and logic** (no `raise UserError` unless in final layer).

---

#### Framework Hooks
Methods used by Odoo internals or extending base models.  
Examples: `create`, `write`, `unlink`, `copy`, `name_get`, `default_get`, `_compute_*`, `_inverse_*`, `_search_*`.

**Rules**
- Always call `super()` unless you explicitly want to block parent logic.
- Keep overrides **thin**: delegate real logic to private helpers.
- Document every override with purpose and constraints.

**Example**
```python
def write(self, vals):
    """Override to log partner updates."""
    res = super().write(vals)
    self._log_partner_update(vals)
    return res
```

---

#### Technical Helpers
Internal helpers meant for reuse inside the same model or module.  
They start with an underscore.

**Rules**
- Never used from XML actions or external modules.
- Contain small, composable logic.
- Must not rely on transient UI context (`self.env.context` is acceptable).

**Example**
```python
def _compute_due_date(self):
    self.due_date = self.invoice_date + timedelta(days=self.payment_term_days)
```

---

#### API Decorators
Odoo provides several decorators to clarify method scope.

| Decorator | Usage | Example |
|----------|-------|---------|
| `@api.model` | No recordset required | setup helpers, `create_from_ui` |
| `@api.model_create_multi` | Accepts multiple vals at once | `create` |
| `@api.depends` | Compute fields dependencies | `_compute_total` |
| `@api.onchange` | Form onchange logic | `_onchange_partner_id` |
| `@api.constrains` | Validation constraints | `_check_amount_positive` |
| `@api.autovacuum` | Periodic cleanup tasks | `_gc_old_records` |

**Rule of thumb:** use the decorator that best represents the logical **scope**, not the easiest to code with.

---

### 6.2. Method Naming Conventions

#### Prefixes by Purpose
| Prefix | Meaning | Example |
|--------|---------|---------|
| `action_` | Triggered by user or button | `action_validate`, `action_send_email` |
| `_compute_` | Field computation | `_compute_amount_total` |
| `_inverse_` | Inverse of computed field | `_inverse_amount_total` |
| `_check_` | Internal validation | `_check_dates_coherence` |
| `_prepare_` | Returns a dict or data structure | `_prepare_invoice_vals` |
| `_get_` | Fetches or resolves something | `_get_partner_data` |
| `_set_` | Assigns something | `_set_state_draft` |
| `_sync_` | Synchronization with external system | `_sync_customer_data` |
| `_run_` | Executed by scheduler or batch | `_run_invoice_auto_post` |

#### Naming Rules
- Use **snake_case**, no camelCase.
- Avoid abbreviations unless common (`qty`, `uom`).
- Use **verbs first**, then objects (`_compute_total`, not `_total_compute`).
- Keep names under **40 characters**.

---

### 6.3. Method Ordering in Classes

Follow a predictable, consistent order in every model:

1. **Default** (`_default_...` methods)
2. **Compute / inverse / constrain methods**
3. **Onchange methods**
4. **Private helpers** (`_prepare_`, `_get_`, `_check_`, `_run_`)
5. **API / integration utilities**
6. **Autovacuum / cron tasks**
7. **Public business methods** (`action_...`)
8. **ORM** (`create`, `write`, `unlink`, etc.)


**Example**
```python
class SaleOrder(models.Model):
    _name = "sale.order"

    ## 1. Defaults
    @api.model
    def _default_partner_id(self): ... 

    ... fields declaration ...

    ## 2. Computed fields
    @api.depends("order_line.price_total")
    def _compute_amount_total(self): ...

    ## 3. Onchange
    @api.onchange("partner_id")
    def _onchange_partner_id(self): ...

    ## 4. Helpers
    def _prepare_invoice_vals(self): ...

    ## 4. Public business methods
    def action_confirm(self): ...

    ## 5. ORM
    def write(self, vals): ...    
```

---

### 6.4. Documentation and Typing

- Always include **docstrings** for public and override methods.  
- Use **type hints** when readability benefits (optional, but encouraged).  
- Private helpers may skip docstring if self-explanatory.

**Example**
```python
def _prepare_invoice_vals(self) -> dict:
    """Prepare the values to create the related invoice."""
    self.ensure_one()
    return {
        "partner_id": self.partner_id.id,
        "invoice_origin": self.name,
    }
```

---

### 6.5. What Not to Do

- Don’t name methods ambiguously (`do_stuff`, `process_data`).  
- Don’t hide side effects behind helper names (`_prepare_` should never write).  
- Don’t use `@api.model` for methods that depend on record state.  
- Don’t put user interaction (`UserError`, `raise`) inside technical helpers.

---
## XX. Assets, OWL and JavaScript

*Content to be written: static structure, OWL 2.0, JS, accessibility.*

## XX. Module Checklist

### XX.1. General

- [ ] Ensure module follows naming conventions.
- [ ] Include a README file with module description and usage instructions.
- [ ] Add necessary documentation (docstrings, comments).

### XX.2. Code Quality

- [ ] Run linters and fix any issues.
- [ ] Write unit tests for all new features.
- [ ] Ensure all tests pass before merging.

### XX.3. Dependencies

- [ ] Declare all dependencies in `requirements.txt`.
- [ ] Ensure compatibility with supported Odoo versions.

### XX.4. Security

- [ ] Review code for security vulnerabilities.
- [ ] Follow best practices for handling sensitive data.

### XX.5. Performance

- [ ] Optimize code for performance where applicable.
- [ ] Include performance benchmarks if relevant.

### XX.6. Compliance

- [ ] Ensure compliance with Apik's development guidelines.
- [ ] Obtain necessary approvals before merging.

## XX. References

*Content to be written: external links to odoo documentation, OCA guidelines, other references.*


## XX. Security and Access Control

*Content to be written: groups, access files, rules, exceptions.*


## XX. Translations

*Content to be written: how to translate, what to translate, best practices.*


## XX. UI/UX Guidelines

*Content to be written: design principles, user research, accessibility, best practices.*


## XX. Views

*Content to be written: structure, view names, widgets, usability.*

---

# Python Versions

<mark> Status: Draft — Pending Review and Approval </mark>

| Odoo | OS | Python | PG client |
| ---- | --- | ---- | ----- |
| 10.0 | Debian Jessie | 2.7.9 | 11.5 |
| 11.0 | Debian Stretch | 3.7.3 | 16 |
| 12.0 | Debian Buster | 3.7.3 | 16 |
| 13.0 | Debian Buster | 3.7.3 | 16 |
| 14.0 | Debian Buster | 3.7.3 | 16 |
| 15.0 | Debian Bullseye | 3.9.2 | 16 |
| 16.0 | Debian Bullseye | 3.9.2 | 16.3 |
| 17.0 | Ubuntu Jammy | 2.7.9 | 16.4 |
| 18.0 | Ubuntu Noble | 3.10.12 | 17 |
| 19.0 | -- | -- | -- |

---

# Release Management Guidelines

<mark> Status: Draft — Pending Review and Approval </mark>

> This document defines **when and how we create, validate, and deliver releases** across environments.  
> It complements workflow, code review, and migrations.
> 
> Releases are the formal milestones of a project — they ensure traceability, stability, and reproducibility.


## Purpose

The goal of the release process is to:
- deliver new features and fixes **safely and predictably**,
- maintain full **traceability** between code, tickets, and deployments,
- provide clear **versioning** for each environment (staging, preproduction, production),
- ensure that the **Technical Referent** has validated every release before delivery,
- allow **controlled inclusion or exclusion** of features requested by the Project Manager.


## Release Strategy

### Branching Model
We follow a **trunk-based workflow**:
- All validated features are merged into `main`.
- The `main` branch is continuously deployable to **staging**.
- Each release is a **Git tag** on `main`:
  - `vX.Y.Z` (semantic versioning)
  - Example: `v1.4.0`

### Environments
| Environment | Source | Purpose |
|--------------|---------|----------|
| **Staging** | `main` branch (auto-deployed) | Internal validation of merged work |
| **Preproduction** | Tagged release | Validation before client delivery |
| **Production** | Tagged release (validated in preprod) | Live system |


## Release Frequency

Releases are created:
- **On demand**, when a Project Manager requests delivery.
- **After validation** of all merged features by the Technical Referent.
- Optionally, **periodically** (e.g. monthly) for maintenance projects.

Rules of thumb:
- Let staging stabilize for at least one validation cycle before tagging.
- One release per day maximum per project to keep history traceable and reversible.


## Selective or Partial Releases

Sometimes, a Project Manager may request to:
- **Exclude specific features** that are not yet functionally validated, or
- **Delay** part of the work while still delivering other features.

### During Preproduction Delivery
When preparing the release:
- The Technical Referent identifies the list of features (tickets) to include.
- If some features must be **excluded**, they can be temporarily **reverted** or **cherry-picked out** before tagging.
- The excluded work remains in `main` but will appear in a later release once validated.

### During Production Delivery
If a feature validated in preproduction is **later refused by the client**:
- A **new release** must be created from the previous validated tag.
- Only the **validated features** are cherry-picked.
- This new tag (e.g. `v1.5.1`) becomes the **production release**, while the unvalidated work stays in staging until confirmation.

All inclusions/exclusions must be documented in:
- the **release description** (Git tag or release notes),
- the **CHANGELOG.md**, specifying which items were deferred.

Example:
```
## [v1.5.1] — Partial release
- Excluded: Partner Import Wizard (pending client validation)
- Included: Subscription price fix, Sale Order Template permissions
```


## Release Creation Process

### Step 1 — Prepare
1. Ensure the `main` branch is up to date and tests pass.
2. Review the `CHANGELOG.md`:
   - Each merged feature has an entry.
   - Migration notes are linked if needed.
3. Validate `MIGRATIONS.md` and command scripts if applicable.
4. Confirm with the Project Manager which tickets are to be included.

### Step 2 — Tag
From the local repo (Technical Referent or release manager):

```bash
git checkout main
git pull
git tag -a v1.5.0 -m "Release v1.5.0 — October 2025"
git push origin v1.5.0
```

For a selective release (excluding some commits):
```bash
git checkout -b release/v1.5.1
git cherry-pick <commit1> <commit2> <commit3>
git tag -a v1.5.1 -m "Release v1.5.1 — selective release"
git push origin v1.5.1
```


## Preproduction and Production Delivery

### Preproduction
- Deploy the tagged image to the preproduction environment.
- Run regression and acceptance tests.
- Validate key use cases with the Project Manager or QA.

### Production
- Deploy **only after approval** by both:
  - **Technical Referent** (technical readiness)
  - **Project Manager** (functional readiness)
- The same tag must be deployed; no untagged code should ever reach production.


## Rollback Policy

If a release causes a regression:
- Rollback to the previous tag:
  ```bash
  git checkout v1.4.0
  ```
- Redeploy the corresponding Docker image or container version.
- Document the issue and resolution in the next changelog.

Rollback safety depends on consistent use of backups and `MIGRATIONS.md` documentation.


## Tagging Rules

| Type | Example | Meaning |
|------|----------|----------|
| **Major** | `v2.0.0` | Incompatible or structural change |
| **Minor** | `v1.5.0` | Backward-compatible new features |
| **Patch** | `v1.5.1` | Fix or partial release (subset of features) |

Guidelines:
- Increment **minor** for functional additions.
- Increment **patch** for fixes or partial deliveries.
- Increment **major** after coordinated agreement across teams.


## Responsibilities

| Role | Responsibility |
|------|----------------|
| **Developer** | Updates changelog and migrations during development |
| **Technical Referent** | Validates code, builds the release, creates and pushes tags |
| **Project Manager (CP)** | Requests release, defines included/excluded scope, validates delivery |
| **Hosting Team** | Deploys preproduction and production environments |
| **QA (optional)** | Performs functional validation |


## Release Checklist

- [ ] All features merged and reviewed.
- [ ] Tests pass on staging.
- [ ] `CHANGELOG.md` and `MIGRATIONS.md` are complete.
- [ ] Scope of release confirmed with Project Manager.
- [ ] Tag created and pushed (`vX.Y.Z`).
- [ ] Preproduction validated.
- [ ] Technical and functional approval received.
- [ ] Production deployment executed.
- [ ] Any exclusions documented in the release note.


## Post-Release Actions

- Monitor logs and alerts for 48h post-deployment.
- Communicate the release summary internally.
- Create follow-up tickets for deferred features.
- Archive release artifacts and backups.


---

# Tools

## apikzilla

What is Apikzilla?

Apikzilla is a **cross-platform command-line tool** (CLI) for **Windows**, **macOS**, and **Linux**, connected to our hosting platform.

It allows you to:
- list available backups for a client project,
- download a backup from the platform,
- upload a backup to a client project.

In short, it serves as the single entry point for managing Odoo backups outside the hosting platform web interface.

- **Source and documentation**: https://github.com/apikcloud/apikzilla-cli
- **Public releases**: https://github.com/apikcloud/apikzilla/releases

---

# Unit Tests

<mark>*Content to be written: unit test strategy, framework, best practices.*</mark>
